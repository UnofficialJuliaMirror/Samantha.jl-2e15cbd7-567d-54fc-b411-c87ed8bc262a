### Imports ###

using MacroTools

### Macros ###

# Wraps a type definition to provide core API methods
# TODO: Break into smaller, modular pieces
macro nodegen(ex::Expr)
  final = Expr(:block)

  # Capture type information
  if @capture(ex, struct (T_{TP__}|T_) fields__ end)
    nothing
  elseif @capture(ex, struct (T_{TP__}|T_) <: TA_ fields__ end)
    nothing
  elseif @capture(ex, mutable struct (T_{TP__}|T_) <: TA_ fields__ end)
    nothing
  elseif @capture(ex, mutable struct (T_{TP__}|T_) fields__ end)
    nothing
  end

  #@assert isdefined(:T) && T != nothing "Failed to parse type definition"
  TP == nothing && (TP = [])
  TPN = []
  TPT = []
  for param in TP
    # TODO: Capture optional values for bounds() and defaultvalue()
    # TODO: Capture all type parameters
    if @capture(param, A_ <: B_)
      push!(TPN, A)
      push!(TPT, B)
    else
      push!(TPN, param)
      push!(TPT, Any)
    end
  end
  TA == nothing && (TA = Any)
  # TODO: Store type data in a method for later retrieval

  # Re-generate type
  push!(final.args, ex)

  #= Generates:
    isnodegenerated
    getindex/setindex!
    params
    TODO: bounds/defaultvalue
    load/store!/sync!
    TODO: show/showall
  =#
  push!(final.args, esc(:(isnodegenerated(__data::$T) = true)))
  params = quote end
  load = Expr(:call, T)
  store = quote settype!(ldbl, $(length(TPN) > 0 ? Expr(:curly, T, TPN...) : T)) end
  sync = quote end
  for (name,typ) in map(f->(f.args...), fields)
    push!(final.args, esc(quote
      Base.getindex(__data::$T, ind::Val{$(QuoteNode(name))}) = __data.$name
    end))
    push!(final.args, esc(quote
      Base.setindex!(__data::$T, val, ind::Val{$(QuoteNode(name))}) = (__data.$name = val)
    end))
    push!(params.args, :(
      __dict[$(QuoteNode(name))] = __data.$name
    ))
    push!(load.args, :(
      load(ldbl, $("$name"), $typ)
    ))
    push!(store.args, :(
      store!(ldbl, $("$name"), __data.$name)
    ))
    push!(sync.args, :(
      sync!(__data.$name)
    ))
  end
  push!(final.args, esc(quote
    Base.getindex(__data::$T, ind::NTuple{N,Val}) where N = __data[ind[1]][ind[2:end]]
    Base.getindex(__data::$T, ind::Tuple{Val}) = __data[ind[1]]
    Base.setindex!(__data::$T, val, ind::NTuple{N,Val}) where N = (__data[ind[1]][ind[2:end]] = val)
    Base.setindex!(__data::$T, val, ind::Tuple{Val}) = (__data[ind[1]] = val)
  end))
  push!(final.args, esc(:(function params(__data::T) where T<:$T
    __dict = Dict{Symbol,Any}()
    $params
    return __dict
  end)))
  ex1 = :(Samantha.load(pldbl::Loadable, name, ::Type{$(Expr(:curly, T, TPN...))}))
  ex2 = :(Samantha.load(pldbl::Loadable, name, ::Type{$T}))
  push!(final.args, Expr(:(=), length(TPN) > 0 ? Expr(:where, ex1, TP...) : ex2, quote
    ldbl = getchild(pldbl, name)
    $load
  end))
  ex1 = :(Samantha.store!(pldbl::Loadable, name, __data::$(Expr(:curly, T, TPN...))))
  ex2 = :(Samantha.store!(pldbl::Loadable, name, __data::$T))
  push!(final.args, Expr(:(=), length(TPN) > 0 ? Expr(:where, ex1, TP...) : ex2, quote
    ldbl = setchild!(pldbl, name)
    $store
  end))
  push!(final.args, esc(:(function sync!(__data::$T)
    $sync
  end)))

  return final
end

# Gets or sets a parameter using Val
# TODO: Convert to prewalk/postwalk so that any operation can be performed
macro param(ex::Expr)
  if @capture(ex, P_[C_])
    return esc(:($P[Val{$(QuoteNode(C))}()]))
  elseif @capture(ex, P_[C_] = V_)
    return esc(:($P[Val{$(QuoteNode(C))}()] = $V))
  end
end

# Unwraps a set of parameters from an object into scope
# TODO: Allow a tuple of names to rename params to
macro unwrap(name, params...)
  ex = Expr(:block)
  for param in params
    push!(ex.args, esc(:($param = @param $name[$(param)])))
  end
  return ex
end

# Threads a loop if possible
macro threadoption(ex::Expr)
  # TODO: Instead check if global USE_THREADS is enabled?
  # FIXME
  return :(
    if canthread()
      Threads.@threads $ex
    else
      @inbounds @simd $ex
    end
  )
end

### Methods ###

# Indicates whether a value is generated by @nodegen
isnodegenerated(x) = false
